#!/bin/bash

export PATH="$PATH:/usr/local/opt/kubernetes-cli/bin/"

alias k=kubectl
alias kc=kubectl
alias kx=kubectx

source <(kubectl completion bash)
complete -F __start_kubectl k
complete -F __start_kubectl kc

source <(helm completion bash)

function kstat {
    if [ -z "$1" ]; then
        namespace="-A"
    else
        namespace="-n $1"
    fi

    watch "kubectl get pods $namespace | grep -v 'Completed'"
}

function kerr {
    if [ -z "$1" ]; then
        namespace="-A"
    else
        namespace="-n $1"
    fi

    watch "kubectl get pods $namespace | grep -v 'Running\|Completed'"
}

function job_rerun {
  NS=$1
  JOB=$2
  if command -v jq; then
    JOB_JSON_ORIGINAL=$(mktemp --suffix=".json")
    kubectl get -n "$NS" jobs "$JOB" -o=json > "$JOB_JSON_ORIGINAL"
    JOB_JSON_RE_RUN=$(mktemp --suffix=".json")
    jq 'del(.status) | del(.metadata.creationTimestamp) | del(.metadata.labels."controller-uid") | del(.metadata.resourceVersion) | del(.metadata.selfLink) | del(.metadata.uid) | del(.spec.selector) | del(.spec.template.metadata.creationTimestamp) | del(.spec.template.metadata.labels."controller-uid" )' "$JOB_JSON_ORIGINAL" > "$JOB_JSON_RE_RUN"
    cat "$JOB_JSON_ORIGINAL" | kubectl delete -f -
    cat "$JOB_JSON_RE_RUN" | kubectl create -f -
  else
    echo "JQ not installed"
  fi
}

function aks-creds {
  RG=$1
  CLUSTER=$2
  az aks get-credentials --resource-group $RG --name $CLUSTER
}

function local-creds {
  sudo cp -r /root/.kube /home/steven/
  sudo chown -R steven:steven /home/steven/.kube
}

function merge-kubeconfig {
  if [[ ! -f ~/.kube/config.bak ]]; then
    cp ~/.kube/config ~/.kube/config.bak
  fi
  new_config=$1
  KUBECONFIG=~/.kube/config:$new_config kubectl config view --flatten > ~/.kube/wtf
  chmod 600 ~/.kube/wtf
  mv ~/.kube/wtf ~/.kube/config
}

function reset-kubeconfig {
  if [[ -f ~/.kube/config.bak ]]; then
    cp ~/.kube/config.bak ~/.kube/config
  fi
}

function simulator-reset {
  rm ~/.ssh/known_hosts
  rm ~/.kube/bootstrap-kubeconfig.yaml
  rm ~/.kube/undercloud-kubeconfig.yaml
  reset-kubeconfig
}


function describe_k8s_resources() {
  describe_resources pods
  describe_resources jobs
  describe_resources cronjobs
  describe_resources deployments
  describe_resources daemonsets
  describe_resources statefulsets
  describe_resources configmaps
  describe_resources secrets
}

function describe_capi_resources() {
  describe_resources clusterclasses
  describe_resources clusterresourcesetbindings
  describe_resources clusterresourcesets
  describe_resources clusters
  describe_resources kubeadmconfigs
  describe_resources kubeadmconfigtemplates
  describe_resources kubeadmcontrolplanes
  describe_resources kubeadmcontrolplanetemplates
  describe_resources machinedeployments
  describe_resources machinehealthchecks
  describe_resources machinepools
  describe_resources machines
  describe_resources machinesets
  describe_resources providers
}

function describe_capm3_resources() {
  describe_resources metal3clusters
  describe_resources metal3dataclaims
  describe_resources metal3datas
  describe_resources metal3datatemplates
  describe_resources metal3machines
  describe_resources metal3machinetemplates
  describe_resources metal3remediations
  describe_resources metal3remediationtemplates
}

function describe_bmo_resources() {
  describe_resources baremetalhosts
  describe_resources firmwareschemas
  describe_resources hostfirmwaresettings
  describe_resources ipaddresses
  describe_resources ipclaims
  describe_resources ippools.ipam.metal3.io
  describe_resources preprovisioningimages
}

function describe_afo_resources() {
  describe_resources baremetalmachines
  describe_resources capiclusters
  describe_resources configs
  describe_resources nodepools
  describe_resources platformclusters
  describe_resources racks
  describe_resources virtualmachineactionpoweroffs
  describe_resources virtualmachineactionreimages
  describe_resources virtualmachineactionrestarts
  describe_resources virtualmachineactionstarts
  describe_resources virtualmachines
  describe_resources workloadnetworks
}

function describe_crs() {
  describe_capi_resources
  describe_capm3_resources
  describe_bmo_resources
  describe_afo_resources
}

function describe_nodes() {
  mkdir -p "$log_dir"/"$cluster"/nodes
  nodes=$(kubectl get nodes -o go-template --template="{{ range .items }}{{ .metadata.name }} {{ end }}")
  for node in $nodes; do
    kubectl describe node "$node" >"$log_dir/$cluster/nodes/$node.txt"
  done
}

function describe_resources() {
  kind=$1
  resources=$(kubectl get "$kind" -n "$namespace" -o go-template --template="{{ range .items }}{{ .metadata.name }} {{ end }}")
  for resource in $resources; do
    mkdir -p "$log_dir/$cluster/$namespace/$kind/$resource"
    kubectl describe -n "$namespace" "$kind" "$resource" >"$log_dir/$cluster/$namespace/$kind/$resource/$resource.txt"
  done
}

function container_logs() {
  pods=$(kubectl get pods -n "$namespace" -o go-template --template="{{ range .items }}{{ .metadata.name }} {{ end }}")
  for pod in $pods; do

    mkdir -p "$log_dir"/"$cluster"/"$namespace"/pods/"$pod"

    init_containers=$(kubectl get pod -n "$namespace" "$pod" -o go-template --template="{{ range .spec.initContainers }}{{ .name }} {{ end }}")
    for container in $init_containers; do
      kubectl logs -n "$namespace" "$pod" -c "$container" >"$log_dir/$cluster/$namespace/pods/$pod/$container.log"
    done

    containers=$(kubectl get pod -n "$namespace" "$pod" -o go-template --template="{{ range .spec.containers }}{{ .name }} {{ end }}")
    for container in $containers; do
      kubectl logs -n "$namespace" "$pod" -c "$container" >"$log_dir/$cluster/$namespace/pods/$pod/$container.log"
    done
  done
}

